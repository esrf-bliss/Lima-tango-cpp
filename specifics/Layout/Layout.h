//=============================================================================
//
// file :        Layout.h
//
// description : Include for the Layout class.
//
// project :	Lima Layout Device Specific
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//		 BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _LAYOUT_H
#define _LAYOUT_H


/**
 * @author	$Author:  $
 * @version	$Revision:  $
 */

//	Add your own constant definitions here.
//-----------------------------------------------
#include "Factory.h"
#include <tango.h>
#include <yat4tango/PropertyHelper.h>
#include <yat4tango/InnerAppender.h>
#include <yat4tango/Logging.h>
#include <yat/threading/Mutex.h>
#include <yat/utils/XString.h>
#include "yat/utils/Logging.h"
#include <yat/time/Timer.h>

#include "lima/HwInterface.h"
#include "lima/CtControl.h"
#include "lima/CtAcquisition.h"
#include "lima/CtImage.h"
#include "lima/SoftOpId.h"
#include "lima/SoftOpExternalMgr.h"
#include "processlib/Data.h"
#include "processlib/TaskMgr.h"
#include <map>


#define MAX_ATTRIBUTE_STRING_LENGTH 	256
#define CURRENT_VERSION                 "1.3.0"

namespace Layout_ns
{

    class LayoutTask : public LinkTask
    {
    public:

        //-----------------------------------------------
		//ctor
		//-----------------------------------------------
        LayoutTask(const std::string& opType, long opValue) :
        LinkTask(true),
        m_operation_type(opType),
        m_operation_value(opValue) { }

        //-----------------------------------------------
		//dtor
		//-----------------------------------------------
        ~LayoutTask(){}       
        
        //-----------------------------------------------
		//define the operation type ( + - * / >> << ROTATION FLIP CIRPAD2x10 CIRPAD4x5)
		//-----------------------------------------------
        void setOperationType(const std::string& opType)
        {            
			m_operation_type = opType;
			transform(m_operation_type.begin(), m_operation_type.end(), m_operation_type.begin(), ::toupper);
        }

        //-----------------------------------------------
		//get the operation type (+ - * / >> << ROTATION FLIP CIRPAD2x10 CIRPAD4x5 )
		//-----------------------------------------------
        const std::string& getOperationType()
        {
            return m_operation_type;
        }
        
        //-----------------------------------------------
		//define the operation value
		//-----------------------------------------------
        void setOperationValue(long opValue)
        {
            m_operation_value = opValue;
        }

        //-----------------------------------------------
		//get the operation value
		//-----------------------------------------------
        long getOperationValue()
        {
            return m_operation_value;
        }
        
		//-----------------------------------------------
		//process is called from lima core for each image and apply operation on it
		//-----------------------------------------------
        Data process(Data &aData)
        {
			yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
			yat::Timer t1;
            Data aNewData;
            switch(aData.type)
            {
                case Data::UINT8: _compute<unsigned char>(aData, aNewData);
                    break;
                case Data::INT8: _compute<char>(aData, aNewData);
                    break;					
                case Data::UINT16: _compute<unsigned short>(aData, aNewData);	
                    break;
                case Data::INT16: _compute<short>(aData, aNewData);
                    break;                    
                case Data::UINT32: _compute<unsigned int>(aData, aNewData);
                    break;
                case Data::INT32: _compute<int>(aData, aNewData);
                    break;   				
				default:
					YAT_INFO<<"Layout: Undefined image Type : "<< aData.type << std::endl;
					break;
            }
			YAT_INFO<<"[Elapsed time : "<<t1.elapsed_msec()<< " (ms)]"<<std::endl;
			YAT_INFO<<" "<< std::endl;				
            return aNewData;
        }

    private:
	
		//-----------------------------------------------
		//CIRPAD ONLY : arrangement of image in order to diplay it on 2 cols and 10 rows
		//-----------------------------------------------
		template<class INPUT>
		Data cirpad_2x10(Data &aSrc)
		{
			YAT_INFO<<"LayoutTask: Apply operation : "<< m_operation_type << " ()"<<std::endl;
			#define MODULE_NB			20
			#define MODULE_WIDTH 		560
			#define MODULE_HEIGHT 		120
			#define MODULE_PIX_NB 		MODULE_HEIGHT*MODULE_WIDTH
			#define MODULE_WIDTH_BYTES 	560*aSrc.depth()
			Data aDst = aSrc.copy();
			aDst.dimensions.clear();
			aDst.dimensions.push_back(2*MODULE_WIDTH);		//width		
			aDst.dimensions.push_back(10*MODULE_HEIGHT);	//height
				
			//idea is to copy each module ligne by line (560 pix) at the right position
			for (int i = 0; i <MODULE_NB; i++) 
			{
				for (int j=0;j<MODULE_HEIGHT;j++)
				{
					if( i%2 == 0 )
						memcpy(&((INPUT*) aDst.data())[(MODULE_WIDTH*2*j + 1*MODULE_WIDTH) + ((i-0)*MODULE_PIX_NB)], &((INPUT*) aSrc.data())[i*MODULE_PIX_NB + MODULE_WIDTH*j], MODULE_WIDTH_BYTES);
					else
						memcpy(&((INPUT*) aDst.data())[(MODULE_WIDTH*2*j + 0*MODULE_WIDTH) + ((i-1)*MODULE_PIX_NB)], &((INPUT*) aSrc.data())[i*MODULE_PIX_NB + MODULE_WIDTH*j], MODULE_WIDTH_BYTES);
				}
			}
					
			return aDst;
		}
		
		//-----------------------------------------------
		//CIRPAD ONLY : arrangement of image in order to diplay it on 4 cols and 5 rows
		//-----------------------------------------------		
		template<class INPUT>
		Data cirpad_4x5(Data &aSrc)
		{
			YAT_INFO<<"LayoutTask: Apply operation : "<< m_operation_type << " ()"<<std::endl;
			#define MODULE_NB			20
			#define MODULE_WIDTH 		560
			#define MODULE_HEIGHT 		120
			#define MODULE_PIX_NB 		MODULE_HEIGHT*MODULE_WIDTH
			#define MODULE_WIDTH_BYTES 	560*aSrc.depth()		
			Data aDst = aSrc.copy();
			aDst.dimensions.clear();
			aDst.dimensions.push_back(4*MODULE_WIDTH);	//width		
			aDst.dimensions.push_back(5*MODULE_HEIGHT);	//height

			//idea is to copy each module ligne by line (560 pix) at the right position
			for (int i = 0; i <MODULE_NB; i++) 
			{
				for (int j=0;j<MODULE_HEIGHT;j++)
				{
					if( i%4 == 0 )
						memcpy(&((INPUT*) aDst.data())[(MODULE_WIDTH*4*j + 3*MODULE_WIDTH) + ((i-0)*MODULE_PIX_NB)], &((INPUT*) aSrc.data())[i*MODULE_PIX_NB + MODULE_WIDTH*j], aSrc.depth()*MODULE_WIDTH);
					else if(i%4==1)
						memcpy(&((INPUT*) aDst.data())[(MODULE_WIDTH*4*j + 2*MODULE_WIDTH) + ((i-1)*MODULE_PIX_NB)], &((INPUT*) aSrc.data())[i*MODULE_PIX_NB + MODULE_WIDTH*j], aSrc.depth()*MODULE_WIDTH);
					else if(i%4==2)
						memcpy(&((INPUT*) aDst.data())[(MODULE_WIDTH*4*j + 1*MODULE_WIDTH) + ((i-2)*MODULE_PIX_NB)], &((INPUT*) aSrc.data())[i*MODULE_PIX_NB + MODULE_WIDTH*j], aSrc.depth()*MODULE_WIDTH);
					else if(i%4==3)
						memcpy(&((INPUT*) aDst.data())[(MODULE_WIDTH*4*j + 0*MODULE_WIDTH) + ((i-3)*MODULE_PIX_NB)], &((INPUT*) aSrc.data())[i*MODULE_PIX_NB + MODULE_WIDTH*j], aSrc.depth()*MODULE_WIDTH);
				}
			}

			return aDst;
		}
		
		//-----------------------------------------------
		//Apply some aritmetic operations (+ - * / >> <<) on image
		//-----------------------------------------------
		template<class INPUT>
		Data operation_arithmetic(Data &aSrc)
		{			
			YAT_INFO<<"LayoutTask: Apply operation arithmetic : "<< m_operation_type << " ("<<m_operation_value<<")"<<std::endl;
			Data aDst = aSrc.copy();
			int aNbPixel = aSrc.dimensions[0] * aSrc.dimensions[1];
			for(int i = 0; i < aNbPixel; i++)
			{
				if(m_operation_type == "+")
					((INPUT*) aDst.data())[i] = ((INPUT*) aSrc.data())[i] + (INPUT)m_operation_value;
				if(m_operation_type == "-")
					((INPUT*) aDst.data())[i] = ((INPUT*) aSrc.data())[i] - (INPUT)m_operation_value;
				if(m_operation_type == "*")
					((INPUT*) aDst.data())[i] = ((INPUT*) aSrc.data())[i] * (INPUT)m_operation_value;
				if(m_operation_type == "/")
					((INPUT*) aDst.data())[i] = (m_operation_value > 0) ? ( ((INPUT*) aSrc.data())[i]/(INPUT)m_operation_value):(((INPUT*) aSrc.data())[i]);
				if(m_operation_type == "<<")
					((INPUT*) aDst.data())[i] = ((INPUT*) aSrc.data())[i]<<(INPUT)m_operation_value;
				if(m_operation_type == ">>")
					((INPUT*) aDst.data())[i] = ((INPUT*) aSrc.data())[i]>>(INPUT)m_operation_value;				
			}
			
			return aDst;
		}
		
		//-----------------------------------------------
		//called by process method
		//-----------------------------------------------		
        template<class INPUT>
        void _compute(Data &aSrc, Data &aDst)
        {
            INPUT *aSrcPt = (INPUT*) aSrc.data();
            INPUT *aDstPt = (INPUT*) aDst.data();
            int aNbPixel = aSrc.dimensions[0] * aSrc.dimensions[1];
			if(m_operation_type == "CIRPAD_2X10")
			{
                aDst = cirpad_2x10<INPUT>(aSrc);
			}
			else if(m_operation_type == "CIRPAD_4X5")
			{
                aDst = cirpad_4x5<INPUT>(aSrc);	
			}
			else
			{
                aDst = operation_arithmetic<INPUT>(aSrc);		
			}
        }

        std::string m_operation_type;
        long m_operation_value;
    };

    /**
     * Class Description:
     * Lima Device Specific for post process image
 */

/*
 *	Device States Description:
*  Tango::INIT :
*  Tango::STANDBY :
*  Tango::FAULT :
*  Tango::RUNNING :
 */


    class Layout : public Tango::Device_4Impl
    {
    public:
        //	Add your own data members here
        //-----------------------------------------


        //	Here is the Start of the automatic code generation part
        //-------------------------------------------------------------	
        /**
         *	@name attributes
         *	Attribute member data.
         */
        //@{
		Tango::DevString	*attr_version_read;
		Tango::DevString	*attr_operationType_read;
		Tango::DevString	attr_operationType_write;
		Tango::DevString	*attr_operationValue_read;
		Tango::DevString	attr_operationValue_write;
		Tango::DevString	*attr_operationsList_read;
//@}

        /**
         * @name Device properties
         * Device properties member data.
         */
        //@{
/**
 *	Memorize all operationType declared in the order to process the image.
 */
	vector<string>	memorizedOperationTypes;
/**
 *	Memorize all operationValue associated to the operationType declared in the order to process the image.
 */
	vector<string>	memorizedOperationValues;
/**
 *	Memorize all levels associated to the operationType declared in the order to process the image.
 */
	vector<long>	memorizedOperationLevels;
//@}

        /**
         *	@name Device properties
         *	Device property member data.
         */
        //@{
        //@}

        /**@name Constructors
         * Miscellaneous constructors */
        //@{
        /**
         * Constructs a newly allocated Command object.
         *
         *	@param cl	Class.
         *	@param s 	Device Name
         */
        Layout(Tango::DeviceClass *cl, string &s);
        /**
         * Constructs a newly allocated Command object.
         *
         *	@param cl	Class.
         *	@param s 	Device Name
         */
        Layout(Tango::DeviceClass *cl, const char *s);
        /**
         * Constructs a newly allocated Command object.
         *
         *	@param cl	Class.
         *	@param s 	Device name
         *	@param d	Device description.
         */
        Layout(Tango::DeviceClass *cl, const char *s, const char *d);
        //@}

        /**@name Destructor
         * Only one destructor is defined for this class */
        //@{

        /**
         * The object destructor.
         */
        ~Layout()
        {
            delete_device();
        };
        /**
         *	will be called at device destruction or at init command.
         */
        void delete_device();
        //@}


        /**@name Miscellaneous methods */
        //@{
        /**
         *	Initialize the device
         */
        virtual void init_device();
        /**
         *	Always executed method before execution command method.
         */
        virtual void always_executed_hook();

//@}

/**
 * @name Layout methods prototypes
 */

//@{
/**
 *	Hardware acquisition for attributes.
 */
	virtual void read_attr_hardware(vector<long> &attr_list);
/**
 *	Extract real attribute values for version acquisition result.
 */
	virtual void read_version(Tango::Attribute &attr);
/**
 *	Extract real attribute values for operationType acquisition result.
 */
	virtual void read_operationType(Tango::Attribute &attr);
/**
 *	Write operationType attribute values to hardware.
 */
	virtual void write_operationType(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for operationValue acquisition result.
 */
	virtual void read_operationValue(Tango::Attribute &attr);
/**
 *	Write operationValue attribute values to hardware.
 */
	virtual void write_operationValue(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for operationsList acquisition result.
 */
	virtual void read_operationsList(Tango::Attribute &attr);
/**
 *	Read/Write allowed for version attribute.
 */
	virtual bool is_version_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for operationType attribute.
 */
	virtual bool is_operationType_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for operationValue attribute.
 */
	virtual bool is_operationValue_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for operationsList attribute.
 */
	virtual bool is_operationsList_allowed(Tango::AttReqType type);
/**
 *	Execution allowed for AddOperation command.
 */
	virtual bool is_AddOperation_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for RemoveOperation command.
 */
	virtual bool is_RemoveOperation_allowed(const CORBA::Any &any);
/**
 * Add Lima external operation in order to transform the image acquired from the detector.<br>
 *	User must first define the operationType, operationValue attributes<br>
 *	argin will define the level of operation.
 *	@param	argin	
 *	@exception DevFailed
 */
	void	add_operation(Tango::DevLong);
/**
 * Remove a Lima external operation previously defined at the the level = argin.<br>
 *	@param	argin	
 *	@exception DevFailed
 */
	void	remove_operation(Tango::DevLong);

/**
 *	Read the device properties from database
 */
	 void get_device_property();
//@}

        //	Here is the end of the automatic code generation part
        //-------------------------------------------------------------	
        Tango::DevState dev_state();

        // return true if the device is correctly initialized in init_device

        bool is_device_initialized()
        {
            return m_is_device_initialized;
        };

        void add_external_operation(long level);
        void delete_external_operation(long level);
        void memorize_all_operations(void);

    protected:
        //	Add your own data members here
        //-----------------------------------------
        bool                                m_is_device_initialized;
        stringstream                        m_status_message;
        std::string                         m_operationType;
        std::string                         m_operationValue;
        
        
        //map used to memorize all active operations
        struct operationParams
        {
            std::string opId;
            std::string operationType;
            std::string operationValue;
        };
        
        std::map<long, operationParams >    m_mapOperations; 
        
        //LIMA objects
        lima::CtControl*                m_ct;
        std::vector<LayoutTask*>        m_layout_tasks;
    };

} // namespace_ns

#endif	// _LAYOUT_H
